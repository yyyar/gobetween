#
# gobetween.toml - sample config file
#
# Website: http://gobetween.io
# Documentation: https://github.com/yyyar/gobetween/wiki/Configuration
#


#
# Logging configuration
#
[logging]
level = "info"   # "debug" | "info" | "warn" | "error"
output = "stdout" # "stdout" | "stderr" | "/path/to/gobetween.log"


#
# REST API server configuration
#
[api]
enabled = true  # true | false
bind = ":8888"  # "host:port"

#  [api.basic_auth]   # (optional) Enable HTTP Basic Auth
#  login = "admin"    # HTTP Auth Login
#  password = "1111"  # HTTP Auth Password

#  [api.tls]                        # (optional) Enable HTTPS
#  cert_path = "/path/to/cert.pem"  # Path to certificate
#  key_path = "/path/to/key.pem"    # Path to key


#
# Default values for server configuration, may be overriden in [servers] sections.
# All "duration" fields (for examole, postfixed with '_timeout') have the following format:
# <int><duration> where duration can be one of 'ms', 's', 'm', 'h'.
# Examples: "5s", "1m", "500ms", etc. "0" value means no limit
#
[defaults] 
max_connections = 0              # Maximum simultaneous connections to the server
client_idle_timeout = "0"        # Client inactivity duration before forced connection drop
backend_idle_timeout = "0"       # Backend inactivity duration before forced connection drop
backend_connection_timeout = "0" # Backend connection timeout


#
# Servers contains as many [server.<name>] sections as needed.
#
[servers]

[servers.sample]
bind = "localhost:3000"

  [servers.sample.discovery]
  kind = "static"
  static_list = [
      "localhost:8000",
      "localhost:8001"
  ]

[servers.udpsample]
bind = "localhost:5443"
protocol = "udp"

  [servers.udpsample.access]
  default = "allow"
  rules = [
    "allow 127.0.0.1",
    "deny 192.168.0.1",
    "allow 192.168.0.1/24",
  ]

  [servers.udpsample.discovery]
  kind = "static"
  static_list = [
      "8.8.8.8:53",
      "8.8.4.4:53",
      "91.239.100.100:53",
      "1.1.1.1:54"
  ]

  [servers.udpsample.healthcheck]
  kind = "udp"
  interval = "2s"
  timeout = "5s"
  send_pattern =     "24 1a 01 00 00 01 00 00000000000377777706676f6f676c6503636f6d0000010001"
  expected_pattern = "24 1a 81 80 00 01 00 (04|05)"


# -------------------- example ----------------------------- #

##
## Example server section.
##

#[servers.default]
#
#bind = "localhost:3000"     #  (required) "<host>:<port>"
#protocol = "tcp"            #  (required) "tcp"
#balance = "weight"          #  (optional [weight]) "weight" | "leastconn" | "roundrobin" | "iphash" | "leastbandwidth"
#
#max_connections = 0
#client_idle_timeout = "10m"
#backend_idle_timeout = "10m"
#backend_connection_timeout = "5s"
#
## -------------------- access management -------------------- #
#
#  [servers.sample.access]   # (optional)
#  default = "allow"         # (required) default access order
#  rules = [                 # (required) list of access rules in
#    "deny 127.0.0.1",       #   the following format: <deny|allow> <ip|network>
#    "deny 192.168.0.1",     #   are checked in sequence until match,
#    "allow 192.168.0.1/24"  #   if no match, use 'default' order. ipv4 and ipv6 are supported
#  ]
#
## -------------------- healthchecks ------------------------- #
#
#  [servers.default.healthcheck]   # (optional)
#  interval = "2s"                 # (required) healthcheck running interval
#  timeout = "0s"                  # (required) max time for healthcheck to execute until mark as failed
#  fails = 1                       # (optional) successfull checks to mark backend as inactive
#  passes = 1                      # (optional) successfull checks to mark backend as active
#
#  # -- ping -- #
#  kind = "ping"                   # Unavailable if server.protocol is udp
#
#  # -- exec -- #
#  kind = "exec"
#  exec_command = "/path/to/healthcheck.sh"      # (required) command to execute
#  exec_expected_positive_output = "1"           # (required) expected output of command in case of success
#  exec_expected_negative_output = "0"           # (required) expected output of command in case of failure
#
#  # -- udp -- #
#  kind = "udp"                                 # Unavailableif server.protocol is tcp
#  send_pattern =     "24 1a 01 00 00 01 00"    # (required) hex pattern to send.
#  expected_pattern = "24 1a 81 00 (04|05)"     # (optional) regexp to check up to 1024 first bytes of the response
#                                               # Default -- any response
#
## -------------------- discovery ---------------------------- #
#
#  [servers.default.discovery]      # (required)
#  failpolicy = "keeplast"          # (optional) "keeplast" | "setempty" - what to do with backends if discovery fails
#  interval = "0s"                  # (required) backends cache invalidation interval; 0 means never.
#  timeout = "5s"                   # (optional) max time to wait for discover until falling to failpolicy
#
#  # -- static -- #
#  kind = "static"
#  static_list = [                  #  (required)  [
#      "localhost:8000 weight=5",   #    "<host>:<port> weight=<int>" weight=1 by default
#      "localhost:8001"             #  ]
#  ]
#
#  # -- srv -- #
#  kind = "srv"
#  srv_lookup_server = "some.server:53"   # (required) "<host:port>"
#  srv_lookup_pattern = "some.service."   # (required) lookup service
#  srv_dns_protocol = "udp"               # (optional) protocol to use for dns lookup
#
#  # -- docker -- #
#  kind = "docker"
#  docker_endpoint = "http://localhost:2375" # (required) Endpoint to docker API
#  docker_container_private_port = 80        # (required) Private port of container to use
#  docker_container_label = "proxied=true"   # (optional) Label to filter containers
#  docker_container_host_env_var = ""        # (optional) Take container host from container env variable
#
#  docker_tls_enabled = false                # (optional) enable client tls auth
#  docker_tls_cert_path = '/path/to/cert.pem'
#  docker_tls_key_path = '/path/to/key.pem'
#  docker_tls_cacert_path = '/path/to/cacert.pem'
#
#  # -- json -- #
#  kind = "json"
#  json_endpoint = "http://some.url.com"   # (required) JSON discovery Url
#  json_host_pattern = "host"              # (optional) path to host value in JSON object, by default "host"
#  json_port_pattern = "port"              # (optional) path to port value in JSON object, by default "port"
#  json_weight_pattern = "weight"          # (optional) path to weight value in JSON object, by default "weight"
#  json_priority_pattern = "priority"      # (optional) path to priority value in JSON object, by default "priority"
#
#  # -- exec -- #
#  kind = "exec"
#  exec_command = ["/path/to/script", "arg1", "arg2"] # (required) command to exec and variable-length arguments
#
#  # -- plaintext -- #
#  kind = "plaintext"
#  plaintext_endpoint = "http://some.url.com"   # (required) Url to plain text discovery
#  plaintext_regex_pattern = ""                 # (optional) Regex with named capturing groups
#
#  # -- consul -- #
#  kind = "consul"
#  consul_host = "localhost:8500"       # (required) Consul host:port
#  consul_service_name = "myservice"    # (required) Service name
#  consul_service_tag = ""              # (optional) Service tag
#  consul_service_passing_only = true   # (optional) Get only services with passing healthchecks
#  consul_service_datacenter = ""       # (optional) Datacenter to use
#
#  consul_auth_username = ""   # (optional) HTTP Basic Auth username
#  consul_auth_password = ""   # (optional) HTTP Basic Auth password
#
#  consul_tls_enabled = true                      # (optional) enable client tls auth
#  consul_tls_cert_path = "/path/to/cert.pem"
#  consul_tls_key_path = "/path/to/key.pem"
#  consul_tls_cacert_path = "/path/to/cacert.pem"
#

